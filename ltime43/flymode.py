#!/usr/bin/env python3

# https://www.codechef.com/LTIME43/problems/FLYMODE
# Timed out.

import io
import sys

def test_data(simple, limit_n, limit_hi):
    if simple:
        '''
        Expected calculation:

        3
        '''

        return io.StringIO(
'''5
1 2 3 2 3
''' 
        )
    else:
        '''
        Assumed limit_n <= limit_hi.
        '''

        distance = int(max((limit_hi // limit_n) / 2, 1))
        mid = limit_hi // 2

        s = str(limit_n) + '\n'
        for i in range(limit_n):
            s += str(mid + distance * (1 if i % 2 == 0 else -1) * int(i / 2 + 0.5)) + ' '

        return io.StringIO(s)

def get_input(source):
    '''
    Returns a tuple (N, map(h1, h2, ..., hn)).
    '''

    with source as lines:
        n = int(next(lines))
        integers = map(int, next(lines).split(' ')[:n])

        return n, integers

def calc(n, heights):
    return calc_limited_window(n, heights)

def calc_window(n, heights):
    '''
    Returns an integer K.

    Too slow: O(N * max(Hi))
    '''

    ranges = []
    min_height = float('inf')
    max_height = 0
    h1 = None
    h2 = next(heights)
    for i in range(n - 1):
        h1 = h2
        h2 = next(heights)

        ranges.append((h1, h2))
        min_height = min(min_height, h1, h2)
        max_height = max(max_height, h1, h2)

    max_count = 0
    for j in range(min_height, max_height + 1):
        j += 0.5
        cur_count = 0

        for r in ranges:
           if j > min(r) and j < max(r):
               cur_count += 1

        if cur_count > max_count:
            max_count = cur_count

    return max_count

def calc_limited_window(n, heights):
    '''
    Returns an integer K.

    Same logic as `calc_window`,
    however instead of placing a window at every integer
    between the minimum and maximum experienced,
    it tries above and below each encountered height.

    That's O(N**2) instead of O(N * max(Hi)),
    which considering 1 <= N <= 10**5, 1 <= Hi <= 10**9,
    is a considerable improvement.

    This is no improvement (and in fact twice as bad)
    when applied to the worst case scenario,
    as generated by the killer tests.
    '''

    distinct_heights = set()
    ranges = []
    h1 = None
    h2 = next(heights)
    for i in range(n - 1):
        h1 = h2
        h2 = next(heights)

        ranges.append((h1, h2))
        distinct_heights.add(h1)
        distinct_heights.add(h2)

    max_count = 0
    def count(n):
        cur_count = 0
        nonlocal max_count

        for r in ranges:
           if n > min(r) and n < max(r):
               cur_count += 1

        if cur_count > max_count:
            max_count = cur_count

    for h in distinct_heights:
        count(h - 0.5)
        count(h + 0.5)

    return max_count

if __name__ == '__main__':
    limit_n = 10 ** 3
    limit_hi = 10 ** 3
    if '-t1' in sys.argv:
        pass
    elif '-t2' in sys.argv:
        limit_n = 10 ** 5
        limit_hi = 10 ** 9

    simple = '-simple' in sys.argv
    inp = test_data(simple, limit_n, limit_hi) if '-test' in sys.argv else sys.stdin

    f = calc
    if '-1' in sys.argv:
        f = calc_window
    elif '-2' in sys.argv:
        f = calc_limited_window

    print(f(*get_input(inp)))

